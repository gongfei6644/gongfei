前情回顾

1. 进程间通信
  
	 消息队列： Queue()  q.put()  q.get()

	 共享内存： Value()  Array()

	 信号量： Semaphore() 
	 	acquire()
		release()


2. 线程

  	【1】 什么是线程
	【2】 线程特点
	【3】 threading 创建线程 （threadpool）
	      Thread()
		start()
		join()
   
	【4】 线程属性
	      
		t.name  t.getName()  t.setName()
		t.daemon  t.setDaemon()  t.isDaemon()
		t.is_alive()  

	【5】 自定义线程类
	     	1. 继承Thread
		2. 编写自己的__init__  run

3.线程通信

  	【1】 通信方法：全局变量
	【2】 同步互斥方法
	      
	Event()   set()  clear()  wait()  is_set()

*************************************************
一. 同步互斥方法 Lock
    
		from  threading  import Lock

		lock = Lock()    创建锁
		lock.acquire()   上锁  如果lock已经上锁会阻塞
		lock.release()   解锁 
		
		with  lock:   上锁
		   	...
			...  
		with 代码块结束自动解锁

二. Python线程的GIL问题
 
 1.效率测试
 
 single cpu: 8.447520017623901
 single IO:  5.697270393371582

 Thread cpu: 8.725268125534058
 Thread IO:  5.536705255508423

 Process cpu: 4.151714563369751
 Process IO: 3.824965000152588


 结论 ： 在无阻塞情况下，多线程程序运行效率和单线程几乎相近，而多进程可以有效的提高程序的运行效率
 
 2. python GIL问题 （全局解释器锁）

   	【1】 什么是GIL ：由于python解释器设计中加入了全局解释器锁，导致python解释器同时只能解释一个线程，

			大大降低了python的执行效率。
    
	【2】 导致后果： 因为遇到阻塞python线程会主动让出解释器，所以python线程在高延迟，

			多阻塞的情况下可以提高运行效率，其他情况并不适合。

	【3】 GIL问题建议
	    	* 修改c解释器

		* 尽量使用进程并发

		* 不使用c作为解释器  （java  c#）
    
三. 进程线程的区别联系

  	【1】 区别联系
	   
		 1. 两者都是多任务编程方式，都能使用计算机多核资源

		 2. 进程的创建和删除消耗的计算机资源比线程多	

     		 3. 进程空间独立，数据互不干扰，有专门通信方法。线程使用全局变量通信

		 4. 一个进程可以包含多个线程，两者存在包含关系

		 5. 多线程共享进程资源，对共享资源操作时往往需要同步互斥处理

		 6. 进程线程都是运行过程描述，有自己的属性标志
	
  	【2】 使用场景

	   	 1. 任务场景： 如果是相对独立的任务模块可能使用进程，如果是多个分支共同构成一个完整功能可能用线程

		 2. 项目结构：多种语言实现不同任务模块可能是多进程。

		 3. 语言特点：比如Java一些语言实现线程资源少效率高，Python有GIL 等

		 4. 难易程度： 通信难度，逻辑处理难度等考量

要求 ： 1. 对进程线程怎么理解/说说进程线程差异特点

	2. 进程间通信都知道哪些，有什么特点

	3. 什么是同步互斥，说说你的使用情况

	4. 给一个情形分析用进程还是线程去实现，怎么实现

	5. 问一些概念，僵尸进程处理，GIL问题，进程状态问题

	6. 就项目问实现方法，为什么


四. 网络通信模型

  1. 通信模型分类

	 	【1】循环网络模型：循环接收客户端请求，处理请求，同时只能处理一个客户端请求任务，处理完再进行下一个。
		  
			 优点：实现简单，占用资源少

			 缺点：无法同时处理多个请求，效率不高

			 适用情况： 客户端不会长期占有服务器，任务比较小，任务量不大。udp比tcp实现更简单
		
		【2】IO并发网络模型：利用IO多路复用等IO模型技术，同时处理多个IO任务请求。

		   	 优点：资源消耗少，能同时处理多个IO

			 缺点：只能处理IO操作
		 
		【3】多进程/线程并发：当一个客户端连接服务器，就创建一个新的进程/线程处理客户端请求，

					客户端退出时对应的进程/线程也随之销毁。
		
		   	 优点： 同时满足多个客户端长期占有服务器需求，可以处理各种请求

			 缺点： 资源消耗较大

			 使用情况：客户端请求比较复杂，处理时间较长，配合较强的服务器部署技术（负载均衡，

					集群技术，分布式处理，缓存队列等）

		
  2. 多进程网络并发

	   基于fork的并发模型
		   
			 * 创建监听套接字

			 * 循环等待客户端连接

			 * 有客户端连接创建新的进程处理客户端请求

			 * 原进程继续等待其他客户端连接

			 * 如果客户端退出，则销毁对应进程


五. ftp文件服务

  1. 功能
	    	【1】 分为服务端和客户端，要求可以多个客户端同时操作

		【2】 客户端可以查看服务器中有哪些文件(普通文件，不包含隐藏的)

		【3】 客户端可以从服务器下载文件到本地目录下

		【4】 客户端可以将本地文件上传的服务端

		【5】 在客户端中端打印简单的命令提示界面
	
  2. 技术分析
	   
		【1】 使用fork多进程并发

		【2】 tcp套接字

		【3】 筛选文件库文件

		      	os.listdir()  获取目录下文件列表

			os.path.isfile() 判断一个文件是否为普通

  3. 结构设计
		 
	客户端：

	  	【1】 客户端启动后先进行网路连接打印界面

		【2】 客户端选择执行的功能进行执行

    	服务端：
		
		【1】 搭建fork并发网络结构等待连接

		【2】 使用子进程循环接收请求处理请求

    请求响应流程： 客户端发起请求--》服务端请求判断能否执行，给客户端反馈--》如果能够执行则进行具体操作

		封装：将2,3,4功能封装为一个类，分别通过方法实现。网络搭建写在main中

  4. 具体功能模块
	  
		* 搭建网络连接

		* 查看文件列表

		* 下载文件

		* 上传文件

		* 客户端退出




